#ifdef DISABLE_PISA
#include "postgres.h"
#include "nodes/pg_list.h"
#include "io/bson_core.h"
#include "pisa_integration/pisa_integration.h"

bool CreatePisaIndex(const char *database_name, const char *collection_name, int compression_type) { return false; }
#else
#else


#include "postgres.h"
#include "fmgr.h"
#include "utils/memutils.h"
#include "utils/builtins.h"
#include "utils/jsonb.h"
#include "catalog/pg_type.h"
#include "access/htup_details.h"
#include "executor/spi.h"

#include "io/bson_core.h"
#include "io/bson_traversal.h"
#include "pisa_integration/data_bridge.h"
#include "pisa_integration/pisa_integration.h"
#include "metadata/collection.h"

typedef struct PisaForwardIndexBuilder
{
    char *output_path;
    FILE *forward_file;
    FILE *document_file;
    int document_count;
    int batch_size;
    List *current_batch;
} PisaForwardIndexBuilder;

static PisaForwardIndexBuilder *CreateForwardIndexBuilder(const char *output_path, int batch_size);
static void FreeForwardIndexBuilder(PisaForwardIndexBuilder *builder);
static bool ProcessDocumentBatch(PisaForwardIndexBuilder *builder);
static bool WriteForwardIndexHeader(PisaForwardIndexBuilder *builder);
static bool WriteDocumentToForwardIndex(PisaForwardIndexBuilder *builder, PisaDocument *doc);

PisaForwardIndexBuilder *
CreateForwardIndexBuilder(const char *output_path, int batch_size)
{
    PisaForwardIndexBuilder *builder;
    char forward_path[MAXPGPATH];
    char document_path[MAXPGPATH];

    builder = (PisaForwardIndexBuilder *) palloc0(sizeof(PisaForwardIndexBuilder));
    builder->output_path = pstrdup(output_path);
    builder->batch_size = batch_size;
    builder->document_count = 0;
    builder->current_batch = NIL;

    snprintf(forward_path, MAXPGPATH, "%s.forward", output_path);
    snprintf(document_path, MAXPGPATH, "%s.documents", output_path);

    builder->forward_file = fopen(forward_path, "w");
    if (builder->forward_file == NULL)
    {
        elog(ERROR, "Failed to create forward index file: %s", forward_path);
        FreeForwardIndexBuilder(builder);
        return NULL;
    }

    builder->document_file = fopen(document_path, "w");
    if (builder->document_file == NULL)
    {
        elog(ERROR, "Failed to create document file: %s", document_path);
        FreeForwardIndexBuilder(builder);
        return NULL;
    }

    WriteForwardIndexHeader(builder);

    return builder;
}

void
FreeForwardIndexBuilder(PisaForwardIndexBuilder *builder)
{
    ListCell *cell;

    if (builder == NULL)
        return;

    if (builder->forward_file)
        fclose(builder->forward_file);
    if (builder->document_file)
        fclose(builder->document_file);

    if (builder->output_path)
        pfree(builder->output_path);

    foreach(cell, builder->current_batch)
    {
        PisaDocument *doc = (PisaDocument *) lfirst(cell);
        FreePisaDocument(doc);
    }
    list_free(builder->current_batch);

    pfree(builder);
}

bool
WriteForwardIndexHeader(PisaForwardIndexBuilder *builder)
{
    if (builder->forward_file == NULL)
        return false;

    fprintf(builder->forward_file, "# PISA Forward Index\n");
    fprintf(builder->forward_file, "# Generated by DocumentDB PISA Integration\n");
    fprintf(builder->forward_file, "# Format: doc_id<TAB>term1 term2 term3...\n");

    return true;
}

bool
WriteDocumentToForwardIndex(PisaForwardIndexBuilder *builder, PisaDocument *doc)
{
    char *tokenized_content;
    char *token;
    char *saveptr;
    StringInfoData processed_content;

    if (builder->forward_file == NULL || doc == NULL)
        return false;

    initStringInfo(&processed_content);

    tokenized_content = pstrdup(doc->content);
    token = strtok_r(tokenized_content, " \t\n\r", &saveptr);

    while (token != NULL)
    {
        if (strlen(token) > 2)
        {
            if (processed_content.len > 0)
                appendStringInfoChar(&processed_content, ' ');
            appendStringInfoString(&processed_content, token);
        }
        token = strtok_r(NULL, " \t\n\r", &saveptr);
    }

    fprintf(builder->forward_file, "%s\t%s\n", doc->doc_id, processed_content.data);
    fprintf(builder->document_file, "%s\t%ld\t%s\n", 
            doc->doc_id, doc->collection_id, doc->content);

    builder->document_count++;

    pfree(tokenized_content);
    pfree(processed_content.data);

    return true;
}

bool
ProcessDocumentBatch(PisaForwardIndexBuilder *builder)
{
    ListCell *cell;
    bool success = true;

    if (builder->current_batch == NIL)
        return true;

    elog(LOG, "Processing batch of %d documents", list_length(builder->current_batch));

    foreach(cell, builder->current_batch)
    {
        PisaDocument *doc = (PisaDocument *) lfirst(cell);
        if (!WriteDocumentToForwardIndex(builder, doc))
        {
            elog(WARNING, "Failed to write document %s to forward index", doc->doc_id);
            success = false;
        }
    }

    foreach(cell, builder->current_batch)
    {
        PisaDocument *doc = (PisaDocument *) lfirst(cell);
        FreePisaDocument(doc);
    }
    list_free(builder->current_batch);
    builder->current_batch = NIL;

    return success;
}

bool
ExportCollectionToPisaForwardIndex(const char *database_name, const char *collection_name,
                                  const char *output_path, PisaExportMode mode)
{
    PisaForwardIndexBuilder *builder;
    List *documents;
    ListCell *cell;
    bool success = true;
    int batch_size = 10000;

    elog(LOG, "Exporting collection %s.%s to PISA forward index: %s", 
         database_name, collection_name, output_path);

    builder = CreateForwardIndexBuilder(output_path, batch_size);
    if (builder == NULL)
        return false;

    PG_TRY();
    {
        documents = ExportCollectionToPisa(database_name, collection_name, mode);
        
        if (documents == NIL)
        {
            elog(WARNING, "No documents found in collection %s.%s", 
                 database_name, collection_name);
            FreeForwardIndexBuilder(builder);
            return false;
        }

        foreach(cell, documents)
        {
            PisaDocument *doc = (PisaDocument *) lfirst(cell);
            builder->current_batch = lappend(builder->current_batch, doc);

            if (list_length(builder->current_batch) >= builder->batch_size)
            {
                if (!ProcessDocumentBatch(builder))
                {
                    success = false;
                    break;
                }
            }
        }

        if (success && builder->current_batch != NIL)
        {
            success = ProcessDocumentBatch(builder);
        }

        if (success)
        {
            elog(LOG, "Successfully exported %d documents to PISA forward index", 
                 builder->document_count);
        }
    }
    PG_CATCH();
    {
        elog(ERROR, "Exception occurred during PISA export for %s.%s", 
             database_name, collection_name);
        success = false;
    }
    PG_END_TRY();

    FreeForwardIndexBuilder(builder);
    return success;
}

bool
BuildPisaInvertedIndex(const char *forward_index_path, const char *output_path)
{
    char command[MAXPGPATH * 3];
    int result;

    elog(LOG, "Building PISA inverted index from forward index: %s", forward_index_path);

    snprintf(command, sizeof(command), 
             "pisa-invert --input %s --output %s --threads 4", 
             forward_index_path, output_path);

    result = system(command);
    
    if (result == 0)
    {
        elog(LOG, "Successfully built PISA inverted index: %s", output_path);
        return true;
    }
    else
    {
        elog(ERROR, "Failed to build PISA inverted index, command returned: %d", result);
        return false;
    }
}

bool
CompressPisaIndex(const char *inverted_index_path, const char *output_path, 
                  PisaCompressionType compression_type)
{
    char command[MAXPGPATH * 3];
    char *compression_name;
    int result;

    switch (compression_type)
    {
        case PISA_COMPRESSION_BLOCK_SIMDBP:
            compression_name = "block_simdbp";
            break;
        case PISA_COMPRESSION_BLOCK_INTERPOLATIVE:
            compression_name = "block_interpolative";
            break;
        case PISA_COMPRESSION_BLOCK_QMXINT:
            compression_name = "block_qmxint";
            break;
        default:
            compression_name = "block_simdbp";
            break;
    }

    elog(LOG, "Compressing PISA index with %s compression: %s", 
         compression_name, inverted_index_path);

    snprintf(command, sizeof(command), 
             "pisa-compress --input %s --output %s --encoding %s", 
             inverted_index_path, output_path, compression_name);

    result = system(command);
    
    if (result == 0)
    {
        elog(LOG, "Successfully compressed PISA index: %s", output_path);
        return true;
    }
    else
    {
        elog(ERROR, "Failed to compress PISA index, command returned: %d", result);
        return false;
    }
}

bool
BuildCompletePisaIndex(const char *database_name, const char *collection_name,
                      const char *base_path, PisaCompressionType compression_type)
{
    char forward_path[MAXPGPATH];
    char inverted_path[MAXPGPATH];
    char compressed_path[MAXPGPATH];
    bool success = true;

    snprintf(forward_path, MAXPGPATH, "%s/%s_%s", base_path, database_name, collection_name);
    snprintf(inverted_path, MAXPGPATH, "%s/%s_%s.inverted", base_path, database_name, collection_name);
    snprintf(compressed_path, MAXPGPATH, "%s/%s_%s.compressed", base_path, database_name, collection_name);

    elog(LOG, "Building complete PISA index for %s.%s", database_name, collection_name);

    PG_TRY();
    {
        if (!ExportCollectionToPisaForwardIndex(database_name, collection_name, 
                                               forward_path, PISA_EXPORT_FULL))
        {
            elog(ERROR, "Failed to export collection to forward index");
            success = false;
        }
        else if (!BuildPisaInvertedIndex(forward_path, inverted_path))
        {
            elog(ERROR, "Failed to build inverted index");
            success = false;
        }
        else if (!CompressPisaIndex(inverted_path, compressed_path, compression_type))
        {
            elog(ERROR, "Failed to compress index");
            success = false;
        }
        else
        {
            elog(LOG, "Successfully built complete PISA index for %s.%s", 
                 database_name, collection_name);
        }
    }
    PG_CATCH();
    {
        elog(ERROR, "Exception occurred during PISA index building for %s.%s", 
             database_name, collection_name);
        success = false;
    }
    PG_END_TRY();

    return success;
}

PG_FUNCTION_INFO_V1(documentdb_export_collection_to_pisa);
Datum
documentdb_export_collection_to_pisa(PG_FUNCTION_ARGS)
{
    text *database_name_text = PG_GETARG_TEXT_PP(0);
    text *collection_name_text = PG_GETARG_TEXT_PP(1);
    text *output_path_text = PG_GETARG_TEXT_PP(2);
    int export_mode = PG_GETARG_INT32(3);
    
    char *database_name = text_to_cstring(database_name_text);
    char *collection_name = text_to_cstring(collection_name_text);
    char *output_path = text_to_cstring(output_path_text);
    
    bool result = ExportCollectionToPisaForwardIndex(database_name, collection_name, 
                                                    output_path, (PisaExportMode) export_mode);
    
    PG_RETURN_BOOL(result);
}

PG_FUNCTION_INFO_V1(documentdb_build_complete_pisa_index);
Datum
documentdb_build_complete_pisa_index(PG_FUNCTION_ARGS)
{
    text *database_name_text = PG_GETARG_TEXT_PP(0);
    text *collection_name_text = PG_GETARG_TEXT_PP(1);
    text *base_path_text = PG_GETARG_TEXT_PP(2);
    int compression_type = PG_GETARG_INT32(3);
    
    char *database_name = text_to_cstring(database_name_text);
    char *collection_name = text_to_cstring(collection_name_text);
    char *base_path = text_to_cstring(base_path_text);
    
    bool result = BuildCompletePisaIndex(database_name, collection_name, 
                                        base_path, (PisaCompressionType) compression_type);
    
    PG_RETURN_BOOL(result);
}
#endif
